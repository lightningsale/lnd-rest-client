/**
 * rpc.proto
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: version not set
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

import ApiClient from '../ApiClient';
import InvoiceInvoiceState from './InvoiceInvoiceState';
import LnrpcFeature from './LnrpcFeature';
import LnrpcInvoiceHTLC from './LnrpcInvoiceHTLC';
import LnrpcRouteHint from './LnrpcRouteHint';

/**
 * The LnrpcInvoice model module.
 * @module model/LnrpcInvoice
 * @version version not set
 */
class LnrpcInvoice {
    /**
     * Constructs a new <code>LnrpcInvoice</code>.
     * @alias module:model/LnrpcInvoice
     */
    constructor() { 
        LnrpcInvoice.initialize(this);
    }

    /**
     * Initializes the fields of this object.
     * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
     * Only for internal use.
     */
    static initialize(obj) { 
    }

    /**
     * Constructs a <code>LnrpcInvoice</code> from a plain JavaScript object, optionally creating a new instance.
     * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @param {module:model/LnrpcInvoice} obj Optional instance to populate.
     * @return {module:model/LnrpcInvoice} The populated <code>LnrpcInvoice</code> instance.
     */
    static constructFromObject(data, obj) {
        if (data) {
            obj = obj || new LnrpcInvoice();

            if (data.hasOwnProperty('memo')) {
                obj['memo'] = ApiClient.convertToType(data['memo'], 'String');
            }
            if (data.hasOwnProperty('r_preimage')) {
                obj['r_preimage'] = ApiClient.convertToType(data['r_preimage'], 'Blob');
            }
            if (data.hasOwnProperty('r_hash')) {
                obj['r_hash'] = ApiClient.convertToType(data['r_hash'], 'Blob');
            }
            if (data.hasOwnProperty('value')) {
                obj['value'] = ApiClient.convertToType(data['value'], 'String');
            }
            if (data.hasOwnProperty('value_msat')) {
                obj['value_msat'] = ApiClient.convertToType(data['value_msat'], 'String');
            }
            if (data.hasOwnProperty('settled')) {
                obj['settled'] = ApiClient.convertToType(data['settled'], 'Boolean');
            }
            if (data.hasOwnProperty('creation_date')) {
                obj['creation_date'] = ApiClient.convertToType(data['creation_date'], 'String');
            }
            if (data.hasOwnProperty('settle_date')) {
                obj['settle_date'] = ApiClient.convertToType(data['settle_date'], 'String');
            }
            if (data.hasOwnProperty('payment_request')) {
                obj['payment_request'] = ApiClient.convertToType(data['payment_request'], 'String');
            }
            if (data.hasOwnProperty('description_hash')) {
                obj['description_hash'] = ApiClient.convertToType(data['description_hash'], 'Blob');
            }
            if (data.hasOwnProperty('expiry')) {
                obj['expiry'] = ApiClient.convertToType(data['expiry'], 'String');
            }
            if (data.hasOwnProperty('fallback_addr')) {
                obj['fallback_addr'] = ApiClient.convertToType(data['fallback_addr'], 'String');
            }
            if (data.hasOwnProperty('cltv_expiry')) {
                obj['cltv_expiry'] = ApiClient.convertToType(data['cltv_expiry'], 'String');
            }
            if (data.hasOwnProperty('route_hints')) {
                obj['route_hints'] = ApiClient.convertToType(data['route_hints'], [LnrpcRouteHint]);
            }
            if (data.hasOwnProperty('private')) {
                obj['private'] = ApiClient.convertToType(data['private'], 'Boolean');
            }
            if (data.hasOwnProperty('add_index')) {
                obj['add_index'] = ApiClient.convertToType(data['add_index'], 'String');
            }
            if (data.hasOwnProperty('settle_index')) {
                obj['settle_index'] = ApiClient.convertToType(data['settle_index'], 'String');
            }
            if (data.hasOwnProperty('amt_paid')) {
                obj['amt_paid'] = ApiClient.convertToType(data['amt_paid'], 'String');
            }
            if (data.hasOwnProperty('amt_paid_sat')) {
                obj['amt_paid_sat'] = ApiClient.convertToType(data['amt_paid_sat'], 'String');
            }
            if (data.hasOwnProperty('amt_paid_msat')) {
                obj['amt_paid_msat'] = ApiClient.convertToType(data['amt_paid_msat'], 'String');
            }
            if (data.hasOwnProperty('state')) {
                obj['state'] = InvoiceInvoiceState.constructFromObject(data['state']);
            }
            if (data.hasOwnProperty('htlcs')) {
                obj['htlcs'] = ApiClient.convertToType(data['htlcs'], [LnrpcInvoiceHTLC]);
            }
            if (data.hasOwnProperty('features')) {
                obj['features'] = ApiClient.convertToType(data['features'], {'String': LnrpcFeature});
            }
            if (data.hasOwnProperty('is_keysend')) {
                obj['is_keysend'] = ApiClient.convertToType(data['is_keysend'], 'Boolean');
            }
            if (data.hasOwnProperty('payment_addr')) {
                obj['payment_addr'] = ApiClient.convertToType(data['payment_addr'], 'Blob');
            }
            if (data.hasOwnProperty('is_amp')) {
                obj['is_amp'] = ApiClient.convertToType(data['is_amp'], 'Boolean');
            }
        }
        return obj;
    }


}

/**
 * An optional memo to attach along with the invoice. Used for record keeping purposes for the invoice's creator, and will also be set in the description field of the encoded payment request if the description_hash field is not being used.
 * @member {String} memo
 */
LnrpcInvoice.prototype['memo'] = undefined;

/**
 * The hex-encoded preimage (32 byte) which will allow settling an incoming HTLC payable to this preimage. When using REST, this field must be encoded as base64.
 * @member {Blob} r_preimage
 */
LnrpcInvoice.prototype['r_preimage'] = undefined;

/**
 * The hash of the preimage. When using REST, this field must be encoded as base64.
 * @member {Blob} r_hash
 */
LnrpcInvoice.prototype['r_hash'] = undefined;

/**
 * The fields value and value_msat are mutually exclusive.
 * @member {String} value
 */
LnrpcInvoice.prototype['value'] = undefined;

/**
 * The fields value and value_msat are mutually exclusive.
 * @member {String} value_msat
 */
LnrpcInvoice.prototype['value_msat'] = undefined;

/**
 * @member {Boolean} settled
 */
LnrpcInvoice.prototype['settled'] = undefined;

/**
 * @member {String} creation_date
 */
LnrpcInvoice.prototype['creation_date'] = undefined;

/**
 * @member {String} settle_date
 */
LnrpcInvoice.prototype['settle_date'] = undefined;

/**
 * A bare-bones invoice for a payment within the Lightning Network. With the details of the invoice, the sender has all the data necessary to send a payment to the recipient.
 * @member {String} payment_request
 */
LnrpcInvoice.prototype['payment_request'] = undefined;

/**
 * Hash (SHA-256) of a description of the payment. Used if the description of payment (memo) is too long to naturally fit within the description field of an encoded payment request. When using REST, this field must be encoded as base64.
 * @member {Blob} description_hash
 */
LnrpcInvoice.prototype['description_hash'] = undefined;

/**
 * Payment request expiry time in seconds. Default is 3600 (1 hour).
 * @member {String} expiry
 */
LnrpcInvoice.prototype['expiry'] = undefined;

/**
 * Fallback on-chain address.
 * @member {String} fallback_addr
 */
LnrpcInvoice.prototype['fallback_addr'] = undefined;

/**
 * Delta to use for the time-lock of the CLTV extended to the final hop.
 * @member {String} cltv_expiry
 */
LnrpcInvoice.prototype['cltv_expiry'] = undefined;

/**
 * Route hints that can each be individually used to assist in reaching the invoice's destination.
 * @member {Array.<module:model/LnrpcRouteHint>} route_hints
 */
LnrpcInvoice.prototype['route_hints'] = undefined;

/**
 * Whether this invoice should include routing hints for private channels.
 * @member {Boolean} private
 */
LnrpcInvoice.prototype['private'] = undefined;

/**
 * The \"add\" index of this invoice. Each newly created invoice will increment this index making it monotonically increasing. Callers to the SubscribeInvoices call can use this to instantly get notified of all added invoices with an add_index greater than this one.
 * @member {String} add_index
 */
LnrpcInvoice.prototype['add_index'] = undefined;

/**
 * The \"settle\" index of this invoice. Each newly settled invoice will increment this index making it monotonically increasing. Callers to the SubscribeInvoices call can use this to instantly get notified of all settled invoices with an settle_index greater than this one.
 * @member {String} settle_index
 */
LnrpcInvoice.prototype['settle_index'] = undefined;

/**
 * Deprecated, use amt_paid_sat or amt_paid_msat.
 * @member {String} amt_paid
 */
LnrpcInvoice.prototype['amt_paid'] = undefined;

/**
 * The amount that was accepted for this invoice, in satoshis. This will ONLY be set if this invoice has been settled. We provide this field as if the invoice was created with a zero value, then we need to record what amount was ultimately accepted. Additionally, it's possible that the sender paid MORE that was specified in the original invoice. So we'll record that here as well.
 * @member {String} amt_paid_sat
 */
LnrpcInvoice.prototype['amt_paid_sat'] = undefined;

/**
 * The amount that was accepted for this invoice, in millisatoshis. This will ONLY be set if this invoice has been settled. We provide this field as if the invoice was created with a zero value, then we need to record what amount was ultimately accepted. Additionally, it's possible that the sender paid MORE that was specified in the original invoice. So we'll record that here as well.
 * @member {String} amt_paid_msat
 */
LnrpcInvoice.prototype['amt_paid_msat'] = undefined;

/**
 * @member {module:model/InvoiceInvoiceState} state
 */
LnrpcInvoice.prototype['state'] = undefined;

/**
 * List of HTLCs paying to this invoice [EXPERIMENTAL].
 * @member {Array.<module:model/LnrpcInvoiceHTLC>} htlcs
 */
LnrpcInvoice.prototype['htlcs'] = undefined;

/**
 * List of features advertised on the invoice.
 * @member {Object.<String, module:model/LnrpcFeature>} features
 */
LnrpcInvoice.prototype['features'] = undefined;

/**
 * Indicates if this invoice was a spontaneous payment that arrived via keysend [EXPERIMENTAL].
 * @member {Boolean} is_keysend
 */
LnrpcInvoice.prototype['is_keysend'] = undefined;

/**
 * The payment address of this invoice. This value will be used in MPP payments, and also for newer invoies that always require the MPP paylaod for added end-to-end security.
 * @member {Blob} payment_addr
 */
LnrpcInvoice.prototype['payment_addr'] = undefined;

/**
 * Signals whether or not this is an AMP invoice.
 * @member {Boolean} is_amp
 */
LnrpcInvoice.prototype['is_amp'] = undefined;






export default LnrpcInvoice;

