/* tslint:disable */
/* eslint-disable */
/**
 * rpc.proto
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: version not set
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    LnrpcAddInvoiceResponse,
    LnrpcAddInvoiceResponseFromJSON,
    LnrpcAddInvoiceResponseToJSON,
    LnrpcBakeMacaroonRequest,
    LnrpcBakeMacaroonRequestFromJSON,
    LnrpcBakeMacaroonRequestToJSON,
    LnrpcBakeMacaroonResponse,
    LnrpcBakeMacaroonResponseFromJSON,
    LnrpcBakeMacaroonResponseToJSON,
    LnrpcChanBackupSnapshot,
    LnrpcChanBackupSnapshotFromJSON,
    LnrpcChanBackupSnapshotToJSON,
    LnrpcChannelAcceptResponse,
    LnrpcChannelAcceptResponseFromJSON,
    LnrpcChannelAcceptResponseToJSON,
    LnrpcChannelBackup,
    LnrpcChannelBackupFromJSON,
    LnrpcChannelBackupToJSON,
    LnrpcChannelBalanceResponse,
    LnrpcChannelBalanceResponseFromJSON,
    LnrpcChannelBalanceResponseToJSON,
    LnrpcChannelEdge,
    LnrpcChannelEdgeFromJSON,
    LnrpcChannelEdgeToJSON,
    LnrpcChannelGraph,
    LnrpcChannelGraphFromJSON,
    LnrpcChannelGraphToJSON,
    LnrpcChannelPoint,
    LnrpcChannelPointFromJSON,
    LnrpcChannelPointToJSON,
    LnrpcClosedChannelsResponse,
    LnrpcClosedChannelsResponseFromJSON,
    LnrpcClosedChannelsResponseToJSON,
    LnrpcConnectPeerRequest,
    LnrpcConnectPeerRequestFromJSON,
    LnrpcConnectPeerRequestToJSON,
    LnrpcDebugLevelRequest,
    LnrpcDebugLevelRequestFromJSON,
    LnrpcDebugLevelRequestToJSON,
    LnrpcDebugLevelResponse,
    LnrpcDebugLevelResponseFromJSON,
    LnrpcDebugLevelResponseToJSON,
    LnrpcDeleteMacaroonIDResponse,
    LnrpcDeleteMacaroonIDResponseFromJSON,
    LnrpcDeleteMacaroonIDResponseToJSON,
    LnrpcEstimateFeeResponse,
    LnrpcEstimateFeeResponseFromJSON,
    LnrpcEstimateFeeResponseToJSON,
    LnrpcFeeReportResponse,
    LnrpcFeeReportResponseFromJSON,
    LnrpcFeeReportResponseToJSON,
    LnrpcForwardingHistoryRequest,
    LnrpcForwardingHistoryRequestFromJSON,
    LnrpcForwardingHistoryRequestToJSON,
    LnrpcForwardingHistoryResponse,
    LnrpcForwardingHistoryResponseFromJSON,
    LnrpcForwardingHistoryResponseToJSON,
    LnrpcFundingTransitionMsg,
    LnrpcFundingTransitionMsgFromJSON,
    LnrpcFundingTransitionMsgToJSON,
    LnrpcGetInfoResponse,
    LnrpcGetInfoResponseFromJSON,
    LnrpcGetInfoResponseToJSON,
    LnrpcGetRecoveryInfoResponse,
    LnrpcGetRecoveryInfoResponseFromJSON,
    LnrpcGetRecoveryInfoResponseToJSON,
    LnrpcInvoice,
    LnrpcInvoiceFromJSON,
    LnrpcInvoiceToJSON,
    LnrpcListChannelsResponse,
    LnrpcListChannelsResponseFromJSON,
    LnrpcListChannelsResponseToJSON,
    LnrpcListInvoiceResponse,
    LnrpcListInvoiceResponseFromJSON,
    LnrpcListInvoiceResponseToJSON,
    LnrpcListMacaroonIDsResponse,
    LnrpcListMacaroonIDsResponseFromJSON,
    LnrpcListMacaroonIDsResponseToJSON,
    LnrpcListPaymentsResponse,
    LnrpcListPaymentsResponseFromJSON,
    LnrpcListPaymentsResponseToJSON,
    LnrpcListPeersResponse,
    LnrpcListPeersResponseFromJSON,
    LnrpcListPeersResponseToJSON,
    LnrpcListPermissionsResponse,
    LnrpcListPermissionsResponseFromJSON,
    LnrpcListPermissionsResponseToJSON,
    LnrpcListUnspentResponse,
    LnrpcListUnspentResponseFromJSON,
    LnrpcListUnspentResponseToJSON,
    LnrpcNetworkInfo,
    LnrpcNetworkInfoFromJSON,
    LnrpcNetworkInfoToJSON,
    LnrpcNewAddressResponse,
    LnrpcNewAddressResponseFromJSON,
    LnrpcNewAddressResponseToJSON,
    LnrpcNodeInfo,
    LnrpcNodeInfoFromJSON,
    LnrpcNodeInfoToJSON,
    LnrpcNodeMetricsResponse,
    LnrpcNodeMetricsResponseFromJSON,
    LnrpcNodeMetricsResponseToJSON,
    LnrpcOpenChannelRequest,
    LnrpcOpenChannelRequestFromJSON,
    LnrpcOpenChannelRequestToJSON,
    LnrpcPayReq,
    LnrpcPayReqFromJSON,
    LnrpcPayReqToJSON,
    LnrpcPendingChannelsResponse,
    LnrpcPendingChannelsResponseFromJSON,
    LnrpcPendingChannelsResponseToJSON,
    LnrpcPolicyUpdateRequest,
    LnrpcPolicyUpdateRequestFromJSON,
    LnrpcPolicyUpdateRequestToJSON,
    LnrpcQueryRoutesResponse,
    LnrpcQueryRoutesResponseFromJSON,
    LnrpcQueryRoutesResponseToJSON,
    LnrpcRestoreChanBackupRequest,
    LnrpcRestoreChanBackupRequestFromJSON,
    LnrpcRestoreChanBackupRequestToJSON,
    LnrpcSendCoinsRequest,
    LnrpcSendCoinsRequestFromJSON,
    LnrpcSendCoinsRequestToJSON,
    LnrpcSendCoinsResponse,
    LnrpcSendCoinsResponseFromJSON,
    LnrpcSendCoinsResponseToJSON,
    LnrpcSendManyRequest,
    LnrpcSendManyRequestFromJSON,
    LnrpcSendManyRequestToJSON,
    LnrpcSendManyResponse,
    LnrpcSendManyResponseFromJSON,
    LnrpcSendManyResponseToJSON,
    LnrpcSendRequest,
    LnrpcSendRequestFromJSON,
    LnrpcSendRequestToJSON,
    LnrpcSendResponse,
    LnrpcSendResponseFromJSON,
    LnrpcSendResponseToJSON,
    LnrpcSendToRouteRequest,
    LnrpcSendToRouteRequestFromJSON,
    LnrpcSendToRouteRequestToJSON,
    LnrpcSignMessageRequest,
    LnrpcSignMessageRequestFromJSON,
    LnrpcSignMessageRequestToJSON,
    LnrpcSignMessageResponse,
    LnrpcSignMessageResponseFromJSON,
    LnrpcSignMessageResponseToJSON,
    LnrpcTransactionDetails,
    LnrpcTransactionDetailsFromJSON,
    LnrpcTransactionDetailsToJSON,
    LnrpcVerifyMessageRequest,
    LnrpcVerifyMessageRequestFromJSON,
    LnrpcVerifyMessageRequestToJSON,
    LnrpcVerifyMessageResponse,
    LnrpcVerifyMessageResponseFromJSON,
    LnrpcVerifyMessageResponseToJSON,
    LnrpcWalletBalanceResponse,
    LnrpcWalletBalanceResponseFromJSON,
    LnrpcWalletBalanceResponseToJSON,
    RuntimeError,
    RuntimeErrorFromJSON,
    RuntimeErrorToJSON,
    StreamResultOfLnrpcChanBackupSnapshot,
    StreamResultOfLnrpcChanBackupSnapshotFromJSON,
    StreamResultOfLnrpcChanBackupSnapshotToJSON,
    StreamResultOfLnrpcChannelAcceptRequest,
    StreamResultOfLnrpcChannelAcceptRequestFromJSON,
    StreamResultOfLnrpcChannelAcceptRequestToJSON,
    StreamResultOfLnrpcChannelEventUpdate,
    StreamResultOfLnrpcChannelEventUpdateFromJSON,
    StreamResultOfLnrpcChannelEventUpdateToJSON,
    StreamResultOfLnrpcCloseStatusUpdate,
    StreamResultOfLnrpcCloseStatusUpdateFromJSON,
    StreamResultOfLnrpcCloseStatusUpdateToJSON,
    StreamResultOfLnrpcGraphTopologyUpdate,
    StreamResultOfLnrpcGraphTopologyUpdateFromJSON,
    StreamResultOfLnrpcGraphTopologyUpdateToJSON,
    StreamResultOfLnrpcInvoice,
    StreamResultOfLnrpcInvoiceFromJSON,
    StreamResultOfLnrpcInvoiceToJSON,
    StreamResultOfLnrpcOpenStatusUpdate,
    StreamResultOfLnrpcOpenStatusUpdateFromJSON,
    StreamResultOfLnrpcOpenStatusUpdateToJSON,
    StreamResultOfLnrpcPeerEvent,
    StreamResultOfLnrpcPeerEventFromJSON,
    StreamResultOfLnrpcPeerEventToJSON,
    StreamResultOfLnrpcSendResponse,
    StreamResultOfLnrpcSendResponseFromJSON,
    StreamResultOfLnrpcSendResponseToJSON,
    StreamResultOfLnrpcTransaction,
    StreamResultOfLnrpcTransactionFromJSON,
    StreamResultOfLnrpcTransactionToJSON,
} from '../models';

export interface AbandonChannelRequest {
    channel_point_funding_txid_str: string;
    channel_point_output_index: number;
    channel_point_funding_txid_bytes?: string;
    pending_funding_shim_only?: boolean;
    i_know_what_i_am_doing?: boolean;
}

export interface AddInvoiceRequest {
    body: LnrpcInvoice;
}

export interface BakeMacaroonRequest {
    body: LnrpcBakeMacaroonRequest;
}

export interface ChannelAcceptorRequest {
    body: LnrpcChannelAcceptResponse;
}

export interface CloseChannelRequest {
    channel_point_funding_txid_str: string;
    channel_point_output_index: number;
    channel_point_funding_txid_bytes?: string;
    force?: boolean;
    target_conf?: number;
    sat_per_byte?: string;
    delivery_address?: string;
    sat_per_vbyte?: string;
}

export interface ClosedChannelsRequest {
    cooperative?: boolean;
    local_force?: boolean;
    remote_force?: boolean;
    breach?: boolean;
    funding_canceled?: boolean;
    abandoned?: boolean;
}

export interface ConnectPeerRequest {
    body: LnrpcConnectPeerRequest;
}

export interface DebugLevelRequest {
    body: LnrpcDebugLevelRequest;
}

export interface DecodePayReqRequest {
    pay_req: string;
}

export interface DeleteAllPaymentsRequest {
    failed_payments_only?: boolean;
    failed_htlcs_only?: boolean;
}

export interface DeleteMacaroonIDRequest {
    root_key_id: string;
}

export interface DescribeGraphRequest {
    include_unannounced?: boolean;
}

export interface DisconnectPeerRequest {
    pub_key: string;
}

export interface EstimateFeeRequest {
    target_conf?: number;
    min_confs?: number;
    spend_unconfirmed?: boolean;
}

export interface ExportChannelBackupRequest {
    chan_point_funding_txid_str: string;
    chan_point_output_index: number;
    chan_point_funding_txid_bytes?: string;
}

export interface ForwardingHistoryRequest {
    body: LnrpcForwardingHistoryRequest;
}

export interface FundingStateStepRequest {
    body: LnrpcFundingTransitionMsg;
}

export interface GetChanInfoRequest {
    chan_id: string;
}

export interface GetNodeInfoRequest {
    pub_key: string;
    include_channels?: boolean;
}

export interface GetNodeMetricsRequest {
    types?: Array<GetNodeMetricsTypesEnum>;
}

export interface GetTransactionsRequest {
    start_height?: number;
    end_height?: number;
    account?: string;
}

export interface ListChannelsRequest {
    active_only?: boolean;
    inactive_only?: boolean;
    public_only?: boolean;
    private_only?: boolean;
    peer?: string;
}

export interface ListInvoicesRequest {
    pending_only?: boolean;
    index_offset?: string;
    num_max_invoices?: string;
    reversed?: boolean;
}

export interface ListPaymentsRequest {
    include_incomplete?: boolean;
    index_offset?: string;
    max_payments?: string;
    reversed?: boolean;
}

export interface ListPeersRequest {
    latest_error?: boolean;
}

export interface ListUnspentRequest {
    min_confs?: number;
    max_confs?: number;
    account?: string;
}

export interface LookupInvoiceRequest {
    r_hash_str: string;
    r_hash?: string;
}

export interface NewAddressRequest {
    type?: NewAddressTypeEnum;
    account?: string;
}

export interface OpenChannelRequest {
    body: LnrpcOpenChannelRequest;
}

export interface OpenChannelSyncRequest {
    body: LnrpcOpenChannelRequest;
}

export interface QueryRoutesRequest {
    pub_key: string;
    amt: string;
    amt_msat?: string;
    final_cltv_delta?: number;
    fee_limit_fixed?: string;
    fee_limit_fixed_msat?: string;
    fee_limit_percent?: string;
    ignored_nodes?: Array<string>;
    source_pub_key?: string;
    use_mission_control?: boolean;
    cltv_limit?: number;
    outgoing_chan_id?: string;
    last_hop_pubkey?: string;
    dest_features?: Array<QueryRoutesDestFeaturesEnum>;
}

export interface RestoreChannelBackupsRequest {
    body: LnrpcRestoreChanBackupRequest;
}

export interface SendCoinsRequest {
    body: LnrpcSendCoinsRequest;
}

export interface SendManyRequest {
    body: LnrpcSendManyRequest;
}

export interface SendPaymentRequest {
    body: LnrpcSendRequest;
}

export interface SendPaymentSyncRequest {
    body: LnrpcSendRequest;
}

export interface SendToRouteSyncRequest {
    body: LnrpcSendToRouteRequest;
}

export interface SignMessageRequest {
    body: LnrpcSignMessageRequest;
}

export interface StopDaemonRequest {
    body: object;
}

export interface SubscribeInvoicesRequest {
    add_index?: string;
    settle_index?: string;
}

export interface SubscribeTransactionsRequest {
    start_height?: number;
    end_height?: number;
    account?: string;
}

export interface UpdateChannelPolicyRequest {
    body: LnrpcPolicyUpdateRequest;
}

export interface VerifyChanBackupRequest {
    body: LnrpcChanBackupSnapshot;
}

export interface VerifyMessageRequest {
    body: LnrpcVerifyMessageRequest;
}

/**
 * 
 */
export class LightningApi extends runtime.BaseAPI {

    /**
     * lncli: `abandonchannel` AbandonChannel removes all channel state from the database except for a close summary. This method can be used to get rid of permanently unusable channels due to bugs fixed in newer versions of lnd. This method can also be used to remove externally funded channels where the funding transaction was never broadcast. Only available for non-externally funded channels in dev build.
     */
    async abandonChannelRaw(requestParameters: AbandonChannelRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.channel_point_funding_txid_str === null || requestParameters.channel_point_funding_txid_str === undefined) {
            throw new runtime.RequiredError('channel_point_funding_txid_str','Required parameter requestParameters.channel_point_funding_txid_str was null or undefined when calling abandonChannel.');
        }

        if (requestParameters.channel_point_output_index === null || requestParameters.channel_point_output_index === undefined) {
            throw new runtime.RequiredError('channel_point_output_index','Required parameter requestParameters.channel_point_output_index was null or undefined when calling abandonChannel.');
        }

        const queryParameters: any = {};

        if (requestParameters.channel_point_funding_txid_bytes !== undefined) {
            queryParameters['channel_point.funding_txid_bytes'] = requestParameters.channel_point_funding_txid_bytes;
        }

        if (requestParameters.pending_funding_shim_only !== undefined) {
            queryParameters['pending_funding_shim_only'] = requestParameters.pending_funding_shim_only;
        }

        if (requestParameters.i_know_what_i_am_doing !== undefined) {
            queryParameters['i_know_what_i_am_doing'] = requestParameters.i_know_what_i_am_doing;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/channels/abandon/{channel_point.funding_txid_str}/{channel_point.output_index}`.replace(`{${"channel_point.funding_txid_str"}}`, encodeURIComponent(String(requestParameters.channel_point_funding_txid_str))).replace(`{${"channel_point.output_index"}}`, encodeURIComponent(String(requestParameters.channel_point_output_index))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * lncli: `abandonchannel` AbandonChannel removes all channel state from the database except for a close summary. This method can be used to get rid of permanently unusable channels due to bugs fixed in newer versions of lnd. This method can also be used to remove externally funded channels where the funding transaction was never broadcast. Only available for non-externally funded channels in dev build.
     */
    async abandonChannel(requestParameters: AbandonChannelRequest, initOverrides?: RequestInit): Promise<object> {
        const response = await this.abandonChannelRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * lncli: `addinvoice` AddInvoice attempts to add a new invoice to the invoice database. Any duplicated invoices are rejected, therefore all invoices *must* have a unique payment preimage.
     */
    async addInvoiceRaw(requestParameters: AddInvoiceRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<LnrpcAddInvoiceResponse>> {
        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling addInvoice.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/v1/invoices`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: LnrpcInvoiceToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => LnrpcAddInvoiceResponseFromJSON(jsonValue));
    }

    /**
     * lncli: `addinvoice` AddInvoice attempts to add a new invoice to the invoice database. Any duplicated invoices are rejected, therefore all invoices *must* have a unique payment preimage.
     */
    async addInvoice(requestParameters: AddInvoiceRequest, initOverrides?: RequestInit): Promise<LnrpcAddInvoiceResponse> {
        const response = await this.addInvoiceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * lncli: `bakemacaroon` BakeMacaroon allows the creation of a new macaroon with custom read and write permissions. No first-party caveats are added since this can be done offline.
     */
    async bakeMacaroonRaw(requestParameters: BakeMacaroonRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<LnrpcBakeMacaroonResponse>> {
        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling bakeMacaroon.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/v1/macaroon`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: LnrpcBakeMacaroonRequestToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => LnrpcBakeMacaroonResponseFromJSON(jsonValue));
    }

    /**
     * lncli: `bakemacaroon` BakeMacaroon allows the creation of a new macaroon with custom read and write permissions. No first-party caveats are added since this can be done offline.
     */
    async bakeMacaroon(requestParameters: BakeMacaroonRequest, initOverrides?: RequestInit): Promise<LnrpcBakeMacaroonResponse> {
        const response = await this.bakeMacaroonRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * ChannelAcceptor dispatches a bi-directional streaming RPC in which OpenChannel requests are sent to the client and the client responds with a boolean that tells LND whether or not to accept the channel. This allows node operators to specify their own criteria for accepting inbound channels through a single persistent connection.
     */
    async channelAcceptorRaw(requestParameters: ChannelAcceptorRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<StreamResultOfLnrpcChannelAcceptRequest>> {
        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling channelAcceptor.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/v1/channels/acceptor`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: LnrpcChannelAcceptResponseToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StreamResultOfLnrpcChannelAcceptRequestFromJSON(jsonValue));
    }

    /**
     * ChannelAcceptor dispatches a bi-directional streaming RPC in which OpenChannel requests are sent to the client and the client responds with a boolean that tells LND whether or not to accept the channel. This allows node operators to specify their own criteria for accepting inbound channels through a single persistent connection.
     */
    async channelAcceptor(requestParameters: ChannelAcceptorRequest, initOverrides?: RequestInit): Promise<StreamResultOfLnrpcChannelAcceptRequest> {
        const response = await this.channelAcceptorRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * lncli: `channelbalance` ChannelBalance returns a report on the total funds across all open channels, categorized in local/remote, pending local/remote and unsettled local/remote balances.
     */
    async channelBalanceRaw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<LnrpcChannelBalanceResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/balance/channels`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => LnrpcChannelBalanceResponseFromJSON(jsonValue));
    }

    /**
     * lncli: `channelbalance` ChannelBalance returns a report on the total funds across all open channels, categorized in local/remote, pending local/remote and unsettled local/remote balances.
     */
    async channelBalance(initOverrides?: RequestInit): Promise<LnrpcChannelBalanceResponse> {
        const response = await this.channelBalanceRaw(initOverrides);
        return await response.value();
    }

    /**
     * lncli: `closechannel` CloseChannel attempts to close an active channel identified by its channel outpoint (ChannelPoint). The actions of this method can additionally be augmented to attempt a force close after a timeout period in the case of an inactive peer. If a non-force close (cooperative closure) is requested, then the user can specify either a target number of blocks until the closure transaction is confirmed, or a manual fee rate. If neither are specified, then a default lax, block confirmation target is used.
     */
    async closeChannelRaw(requestParameters: CloseChannelRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<StreamResultOfLnrpcCloseStatusUpdate>> {
        if (requestParameters.channel_point_funding_txid_str === null || requestParameters.channel_point_funding_txid_str === undefined) {
            throw new runtime.RequiredError('channel_point_funding_txid_str','Required parameter requestParameters.channel_point_funding_txid_str was null or undefined when calling closeChannel.');
        }

        if (requestParameters.channel_point_output_index === null || requestParameters.channel_point_output_index === undefined) {
            throw new runtime.RequiredError('channel_point_output_index','Required parameter requestParameters.channel_point_output_index was null or undefined when calling closeChannel.');
        }

        const queryParameters: any = {};

        if (requestParameters.channel_point_funding_txid_bytes !== undefined) {
            queryParameters['channel_point.funding_txid_bytes'] = requestParameters.channel_point_funding_txid_bytes;
        }

        if (requestParameters.force !== undefined) {
            queryParameters['force'] = requestParameters.force;
        }

        if (requestParameters.target_conf !== undefined) {
            queryParameters['target_conf'] = requestParameters.target_conf;
        }

        if (requestParameters.sat_per_byte !== undefined) {
            queryParameters['sat_per_byte'] = requestParameters.sat_per_byte;
        }

        if (requestParameters.delivery_address !== undefined) {
            queryParameters['delivery_address'] = requestParameters.delivery_address;
        }

        if (requestParameters.sat_per_vbyte !== undefined) {
            queryParameters['sat_per_vbyte'] = requestParameters.sat_per_vbyte;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/channels/{channel_point.funding_txid_str}/{channel_point.output_index}`.replace(`{${"channel_point.funding_txid_str"}}`, encodeURIComponent(String(requestParameters.channel_point_funding_txid_str))).replace(`{${"channel_point.output_index"}}`, encodeURIComponent(String(requestParameters.channel_point_output_index))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StreamResultOfLnrpcCloseStatusUpdateFromJSON(jsonValue));
    }

    /**
     * lncli: `closechannel` CloseChannel attempts to close an active channel identified by its channel outpoint (ChannelPoint). The actions of this method can additionally be augmented to attempt a force close after a timeout period in the case of an inactive peer. If a non-force close (cooperative closure) is requested, then the user can specify either a target number of blocks until the closure transaction is confirmed, or a manual fee rate. If neither are specified, then a default lax, block confirmation target is used.
     */
    async closeChannel(requestParameters: CloseChannelRequest, initOverrides?: RequestInit): Promise<StreamResultOfLnrpcCloseStatusUpdate> {
        const response = await this.closeChannelRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * lncli: `closedchannels` ClosedChannels returns a description of all the closed channels that this node was a participant in.
     */
    async closedChannelsRaw(requestParameters: ClosedChannelsRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<LnrpcClosedChannelsResponse>> {
        const queryParameters: any = {};

        if (requestParameters.cooperative !== undefined) {
            queryParameters['cooperative'] = requestParameters.cooperative;
        }

        if (requestParameters.local_force !== undefined) {
            queryParameters['local_force'] = requestParameters.local_force;
        }

        if (requestParameters.remote_force !== undefined) {
            queryParameters['remote_force'] = requestParameters.remote_force;
        }

        if (requestParameters.breach !== undefined) {
            queryParameters['breach'] = requestParameters.breach;
        }

        if (requestParameters.funding_canceled !== undefined) {
            queryParameters['funding_canceled'] = requestParameters.funding_canceled;
        }

        if (requestParameters.abandoned !== undefined) {
            queryParameters['abandoned'] = requestParameters.abandoned;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/channels/closed`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => LnrpcClosedChannelsResponseFromJSON(jsonValue));
    }

    /**
     * lncli: `closedchannels` ClosedChannels returns a description of all the closed channels that this node was a participant in.
     */
    async closedChannels(requestParameters: ClosedChannelsRequest, initOverrides?: RequestInit): Promise<LnrpcClosedChannelsResponse> {
        const response = await this.closedChannelsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * lncli: `connect` ConnectPeer attempts to establish a connection to a remote peer. This is at the networking level, and is used for communication between nodes. This is distinct from establishing a channel with a peer.
     */
    async connectPeerRaw(requestParameters: ConnectPeerRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling connectPeer.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/v1/peers`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: LnrpcConnectPeerRequestToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * lncli: `connect` ConnectPeer attempts to establish a connection to a remote peer. This is at the networking level, and is used for communication between nodes. This is distinct from establishing a channel with a peer.
     */
    async connectPeer(requestParameters: ConnectPeerRequest, initOverrides?: RequestInit): Promise<object> {
        const response = await this.connectPeerRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * lncli: `debuglevel` DebugLevel allows a caller to programmatically set the logging verbosity of lnd. The logging can be targeted according to a coarse daemon-wide logging level, or in a granular fashion to specify the logging for a target sub-system.
     */
    async debugLevelRaw(requestParameters: DebugLevelRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<LnrpcDebugLevelResponse>> {
        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling debugLevel.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/v1/debuglevel`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: LnrpcDebugLevelRequestToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => LnrpcDebugLevelResponseFromJSON(jsonValue));
    }

    /**
     * lncli: `debuglevel` DebugLevel allows a caller to programmatically set the logging verbosity of lnd. The logging can be targeted according to a coarse daemon-wide logging level, or in a granular fashion to specify the logging for a target sub-system.
     */
    async debugLevel(requestParameters: DebugLevelRequest, initOverrides?: RequestInit): Promise<LnrpcDebugLevelResponse> {
        const response = await this.debugLevelRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * lncli: `decodepayreq` DecodePayReq takes an encoded payment request string and attempts to decode it, returning a full description of the conditions encoded within the payment request.
     */
    async decodePayReqRaw(requestParameters: DecodePayReqRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<LnrpcPayReq>> {
        if (requestParameters.pay_req === null || requestParameters.pay_req === undefined) {
            throw new runtime.RequiredError('pay_req','Required parameter requestParameters.pay_req was null or undefined when calling decodePayReq.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/payreq/{pay_req}`.replace(`{${"pay_req"}}`, encodeURIComponent(String(requestParameters.pay_req))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => LnrpcPayReqFromJSON(jsonValue));
    }

    /**
     * lncli: `decodepayreq` DecodePayReq takes an encoded payment request string and attempts to decode it, returning a full description of the conditions encoded within the payment request.
     */
    async decodePayReq(requestParameters: DecodePayReqRequest, initOverrides?: RequestInit): Promise<LnrpcPayReq> {
        const response = await this.decodePayReqRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * DeleteAllPayments deletes all outgoing payments from DB.
     */
    async deleteAllPaymentsRaw(requestParameters: DeleteAllPaymentsRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<object>> {
        const queryParameters: any = {};

        if (requestParameters.failed_payments_only !== undefined) {
            queryParameters['failed_payments_only'] = requestParameters.failed_payments_only;
        }

        if (requestParameters.failed_htlcs_only !== undefined) {
            queryParameters['failed_htlcs_only'] = requestParameters.failed_htlcs_only;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/payments`,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * DeleteAllPayments deletes all outgoing payments from DB.
     */
    async deleteAllPayments(requestParameters: DeleteAllPaymentsRequest, initOverrides?: RequestInit): Promise<object> {
        const response = await this.deleteAllPaymentsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * lncli: `deletemacaroonid` DeleteMacaroonID deletes the specified macaroon ID and invalidates all macaroons derived from that ID.
     */
    async deleteMacaroonIDRaw(requestParameters: DeleteMacaroonIDRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<LnrpcDeleteMacaroonIDResponse>> {
        if (requestParameters.root_key_id === null || requestParameters.root_key_id === undefined) {
            throw new runtime.RequiredError('root_key_id','Required parameter requestParameters.root_key_id was null or undefined when calling deleteMacaroonID.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/macaroon/{root_key_id}`.replace(`{${"root_key_id"}}`, encodeURIComponent(String(requestParameters.root_key_id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => LnrpcDeleteMacaroonIDResponseFromJSON(jsonValue));
    }

    /**
     * lncli: `deletemacaroonid` DeleteMacaroonID deletes the specified macaroon ID and invalidates all macaroons derived from that ID.
     */
    async deleteMacaroonID(requestParameters: DeleteMacaroonIDRequest, initOverrides?: RequestInit): Promise<LnrpcDeleteMacaroonIDResponse> {
        const response = await this.deleteMacaroonIDRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * lncli: `describegraph` DescribeGraph returns a description of the latest graph state from the point of view of the node. The graph information is partitioned into two components: all the nodes/vertexes, and all the edges that connect the vertexes themselves. As this is a directed graph, the edges also contain the node directional specific routing policy which includes: the time lock delta, fee information, etc.
     */
    async describeGraphRaw(requestParameters: DescribeGraphRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<LnrpcChannelGraph>> {
        const queryParameters: any = {};

        if (requestParameters.include_unannounced !== undefined) {
            queryParameters['include_unannounced'] = requestParameters.include_unannounced;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/graph`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => LnrpcChannelGraphFromJSON(jsonValue));
    }

    /**
     * lncli: `describegraph` DescribeGraph returns a description of the latest graph state from the point of view of the node. The graph information is partitioned into two components: all the nodes/vertexes, and all the edges that connect the vertexes themselves. As this is a directed graph, the edges also contain the node directional specific routing policy which includes: the time lock delta, fee information, etc.
     */
    async describeGraph(requestParameters: DescribeGraphRequest, initOverrides?: RequestInit): Promise<LnrpcChannelGraph> {
        const response = await this.describeGraphRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * lncli: `disconnect` DisconnectPeer attempts to disconnect one peer from another identified by a given pubKey. In the case that we currently have a pending or active channel with the target peer, then this action will be not be allowed.
     */
    async disconnectPeerRaw(requestParameters: DisconnectPeerRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.pub_key === null || requestParameters.pub_key === undefined) {
            throw new runtime.RequiredError('pub_key','Required parameter requestParameters.pub_key was null or undefined when calling disconnectPeer.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/peers/{pub_key}`.replace(`{${"pub_key"}}`, encodeURIComponent(String(requestParameters.pub_key))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * lncli: `disconnect` DisconnectPeer attempts to disconnect one peer from another identified by a given pubKey. In the case that we currently have a pending or active channel with the target peer, then this action will be not be allowed.
     */
    async disconnectPeer(requestParameters: DisconnectPeerRequest, initOverrides?: RequestInit): Promise<object> {
        const response = await this.disconnectPeerRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * When using REST, the `AddrToAmount` map type can be set by appending `&AddrToAmount[<address>]=<amount_to_send>` to the URL. Unfortunately this map type doesn\'t appear in the REST API documentation because of a bug in the grpc-gateway library.
     * lncli: `estimatefee` EstimateFee asks the chain backend to estimate the fee rate and total fees for a transaction that pays to multiple specified outputs.
     */
    async estimateFeeRaw(requestParameters: EstimateFeeRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<LnrpcEstimateFeeResponse>> {
        const queryParameters: any = {};

        if (requestParameters.target_conf !== undefined) {
            queryParameters['target_conf'] = requestParameters.target_conf;
        }

        if (requestParameters.min_confs !== undefined) {
            queryParameters['min_confs'] = requestParameters.min_confs;
        }

        if (requestParameters.spend_unconfirmed !== undefined) {
            queryParameters['spend_unconfirmed'] = requestParameters.spend_unconfirmed;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/transactions/fee`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => LnrpcEstimateFeeResponseFromJSON(jsonValue));
    }

    /**
     * When using REST, the `AddrToAmount` map type can be set by appending `&AddrToAmount[<address>]=<amount_to_send>` to the URL. Unfortunately this map type doesn\'t appear in the REST API documentation because of a bug in the grpc-gateway library.
     * lncli: `estimatefee` EstimateFee asks the chain backend to estimate the fee rate and total fees for a transaction that pays to multiple specified outputs.
     */
    async estimateFee(requestParameters: EstimateFeeRequest, initOverrides?: RequestInit): Promise<LnrpcEstimateFeeResponse> {
        const response = await this.estimateFeeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * ExportAllChannelBackups returns static channel backups for all existing channels known to lnd. A set of regular singular static channel backups for each channel are returned. Additionally, a multi-channel backup is returned as well, which contains a single encrypted blob containing the backups of each channel.
     */
    async exportAllChannelBackupsRaw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<LnrpcChanBackupSnapshot>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/channels/backup`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => LnrpcChanBackupSnapshotFromJSON(jsonValue));
    }

    /**
     * ExportAllChannelBackups returns static channel backups for all existing channels known to lnd. A set of regular singular static channel backups for each channel are returned. Additionally, a multi-channel backup is returned as well, which contains a single encrypted blob containing the backups of each channel.
     */
    async exportAllChannelBackups(initOverrides?: RequestInit): Promise<LnrpcChanBackupSnapshot> {
        const response = await this.exportAllChannelBackupsRaw(initOverrides);
        return await response.value();
    }

    /**
     * lncli: `exportchanbackup` ExportChannelBackup attempts to return an encrypted static channel backup for the target channel identified by it channel point. The backup is encrypted with a key generated from the aezeed seed of the user. The returned backup can either be restored using the RestoreChannelBackup method once lnd is running, or via the InitWallet and UnlockWallet methods from the WalletUnlocker service.
     */
    async exportChannelBackupRaw(requestParameters: ExportChannelBackupRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<LnrpcChannelBackup>> {
        if (requestParameters.chan_point_funding_txid_str === null || requestParameters.chan_point_funding_txid_str === undefined) {
            throw new runtime.RequiredError('chan_point_funding_txid_str','Required parameter requestParameters.chan_point_funding_txid_str was null or undefined when calling exportChannelBackup.');
        }

        if (requestParameters.chan_point_output_index === null || requestParameters.chan_point_output_index === undefined) {
            throw new runtime.RequiredError('chan_point_output_index','Required parameter requestParameters.chan_point_output_index was null or undefined when calling exportChannelBackup.');
        }

        const queryParameters: any = {};

        if (requestParameters.chan_point_funding_txid_bytes !== undefined) {
            queryParameters['chan_point.funding_txid_bytes'] = requestParameters.chan_point_funding_txid_bytes;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/channels/backup/{chan_point.funding_txid_str}/{chan_point.output_index}`.replace(`{${"chan_point.funding_txid_str"}}`, encodeURIComponent(String(requestParameters.chan_point_funding_txid_str))).replace(`{${"chan_point.output_index"}}`, encodeURIComponent(String(requestParameters.chan_point_output_index))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => LnrpcChannelBackupFromJSON(jsonValue));
    }

    /**
     * lncli: `exportchanbackup` ExportChannelBackup attempts to return an encrypted static channel backup for the target channel identified by it channel point. The backup is encrypted with a key generated from the aezeed seed of the user. The returned backup can either be restored using the RestoreChannelBackup method once lnd is running, or via the InitWallet and UnlockWallet methods from the WalletUnlocker service.
     */
    async exportChannelBackup(requestParameters: ExportChannelBackupRequest, initOverrides?: RequestInit): Promise<LnrpcChannelBackup> {
        const response = await this.exportChannelBackupRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * lncli: `feereport` FeeReport allows the caller to obtain a report detailing the current fee schedule enforced by the node globally for each channel.
     */
    async feeReportRaw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<LnrpcFeeReportResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/fees`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => LnrpcFeeReportResponseFromJSON(jsonValue));
    }

    /**
     * lncli: `feereport` FeeReport allows the caller to obtain a report detailing the current fee schedule enforced by the node globally for each channel.
     */
    async feeReport(initOverrides?: RequestInit): Promise<LnrpcFeeReportResponse> {
        const response = await this.feeReportRaw(initOverrides);
        return await response.value();
    }

    /**
     * A list of forwarding events are returned. The size of each forwarding event is 40 bytes, and the max message size able to be returned in gRPC is 4 MiB. As a result each message can only contain 50k entries. Each response has the index offset of the last entry. The index offset can be provided to the request to allow the caller to skip a series of records.
     * lncli: `fwdinghistory` ForwardingHistory allows the caller to query the htlcswitch for a record of all HTLCs forwarded within the target time range, and integer offset within that time range, for a maximum number of events. If no maximum number of events is specified, up to 100 events will be returned. If no time-range is specified, then events will be returned in the order that they occured.
     */
    async forwardingHistoryRaw(requestParameters: ForwardingHistoryRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<LnrpcForwardingHistoryResponse>> {
        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling forwardingHistory.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/v1/switch`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: LnrpcForwardingHistoryRequestToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => LnrpcForwardingHistoryResponseFromJSON(jsonValue));
    }

    /**
     * A list of forwarding events are returned. The size of each forwarding event is 40 bytes, and the max message size able to be returned in gRPC is 4 MiB. As a result each message can only contain 50k entries. Each response has the index offset of the last entry. The index offset can be provided to the request to allow the caller to skip a series of records.
     * lncli: `fwdinghistory` ForwardingHistory allows the caller to query the htlcswitch for a record of all HTLCs forwarded within the target time range, and integer offset within that time range, for a maximum number of events. If no maximum number of events is specified, up to 100 events will be returned. If no time-range is specified, then events will be returned in the order that they occured.
     */
    async forwardingHistory(requestParameters: ForwardingHistoryRequest, initOverrides?: RequestInit): Promise<LnrpcForwardingHistoryResponse> {
        const response = await this.forwardingHistoryRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * FundingStateStep is an advanced funding related call that allows the caller to either execute some preparatory steps for a funding workflow, or manually progress a funding workflow. The primary way a funding flow is identified is via its pending channel ID. As an example, this method can be used to specify that we\'re expecting a funding flow for a particular pending channel ID, for which we need to use specific parameters. Alternatively, this can be used to interactively drive PSBT signing for funding for partially complete funding transactions.
     */
    async fundingStateStepRaw(requestParameters: FundingStateStepRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling fundingStateStep.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/v1/funding/step`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: LnrpcFundingTransitionMsgToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * FundingStateStep is an advanced funding related call that allows the caller to either execute some preparatory steps for a funding workflow, or manually progress a funding workflow. The primary way a funding flow is identified is via its pending channel ID. As an example, this method can be used to specify that we\'re expecting a funding flow for a particular pending channel ID, for which we need to use specific parameters. Alternatively, this can be used to interactively drive PSBT signing for funding for partially complete funding transactions.
     */
    async fundingStateStep(requestParameters: FundingStateStepRequest, initOverrides?: RequestInit): Promise<object> {
        const response = await this.fundingStateStepRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * lncli: `getchaninfo` GetChanInfo returns the latest authenticated network announcement for the given channel identified by its channel ID: an 8-byte integer which uniquely identifies the location of transaction\'s funding output within the blockchain.
     */
    async getChanInfoRaw(requestParameters: GetChanInfoRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<LnrpcChannelEdge>> {
        if (requestParameters.chan_id === null || requestParameters.chan_id === undefined) {
            throw new runtime.RequiredError('chan_id','Required parameter requestParameters.chan_id was null or undefined when calling getChanInfo.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/graph/edge/{chan_id}`.replace(`{${"chan_id"}}`, encodeURIComponent(String(requestParameters.chan_id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => LnrpcChannelEdgeFromJSON(jsonValue));
    }

    /**
     * lncli: `getchaninfo` GetChanInfo returns the latest authenticated network announcement for the given channel identified by its channel ID: an 8-byte integer which uniquely identifies the location of transaction\'s funding output within the blockchain.
     */
    async getChanInfo(requestParameters: GetChanInfoRequest, initOverrides?: RequestInit): Promise<LnrpcChannelEdge> {
        const response = await this.getChanInfoRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * lncli: `getinfo` GetInfo returns general information concerning the lightning node including it\'s identity pubkey, alias, the chains it is connected to, and information concerning the number of open+pending channels.
     */
    async getInfoRaw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<LnrpcGetInfoResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/getinfo`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => LnrpcGetInfoResponseFromJSON(jsonValue));
    }

    /**
     * lncli: `getinfo` GetInfo returns general information concerning the lightning node including it\'s identity pubkey, alias, the chains it is connected to, and information concerning the number of open+pending channels.
     */
    async getInfo(initOverrides?: RequestInit): Promise<LnrpcGetInfoResponse> {
        const response = await this.getInfoRaw(initOverrides);
        return await response.value();
    }

    /**
     * lncli: `getnetworkinfo` GetNetworkInfo returns some basic stats about the known channel graph from the point of view of the node.
     */
    async getNetworkInfoRaw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<LnrpcNetworkInfo>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/graph/info`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => LnrpcNetworkInfoFromJSON(jsonValue));
    }

    /**
     * lncli: `getnetworkinfo` GetNetworkInfo returns some basic stats about the known channel graph from the point of view of the node.
     */
    async getNetworkInfo(initOverrides?: RequestInit): Promise<LnrpcNetworkInfo> {
        const response = await this.getNetworkInfoRaw(initOverrides);
        return await response.value();
    }

    /**
     * lncli: `getnodeinfo` GetNodeInfo returns the latest advertised, aggregated, and authenticated channel information for the specified node identified by its public key.
     */
    async getNodeInfoRaw(requestParameters: GetNodeInfoRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<LnrpcNodeInfo>> {
        if (requestParameters.pub_key === null || requestParameters.pub_key === undefined) {
            throw new runtime.RequiredError('pub_key','Required parameter requestParameters.pub_key was null or undefined when calling getNodeInfo.');
        }

        const queryParameters: any = {};

        if (requestParameters.include_channels !== undefined) {
            queryParameters['include_channels'] = requestParameters.include_channels;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/graph/node/{pub_key}`.replace(`{${"pub_key"}}`, encodeURIComponent(String(requestParameters.pub_key))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => LnrpcNodeInfoFromJSON(jsonValue));
    }

    /**
     * lncli: `getnodeinfo` GetNodeInfo returns the latest advertised, aggregated, and authenticated channel information for the specified node identified by its public key.
     */
    async getNodeInfo(requestParameters: GetNodeInfoRequest, initOverrides?: RequestInit): Promise<LnrpcNodeInfo> {
        const response = await this.getNodeInfoRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * lncli: `getnodemetrics` GetNodeMetrics returns node metrics calculated from the graph. Currently the only supported metric is betweenness centrality of individual nodes.
     */
    async getNodeMetricsRaw(requestParameters: GetNodeMetricsRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<LnrpcNodeMetricsResponse>> {
        const queryParameters: any = {};

        if (requestParameters.types) {
            queryParameters['types'] = requestParameters.types;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/graph/nodemetrics`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => LnrpcNodeMetricsResponseFromJSON(jsonValue));
    }

    /**
     * lncli: `getnodemetrics` GetNodeMetrics returns node metrics calculated from the graph. Currently the only supported metric is betweenness centrality of individual nodes.
     */
    async getNodeMetrics(requestParameters: GetNodeMetricsRequest, initOverrides?: RequestInit): Promise<LnrpcNodeMetricsResponse> {
        const response = await this.getNodeMetricsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * * lncli: `getrecoveryinfo` GetRecoveryInfo returns information concerning the recovery mode including whether it\'s in a recovery mode, whether the recovery is finished, and the progress made so far.
     */
    async getRecoveryInfoRaw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<LnrpcGetRecoveryInfoResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/getrecoveryinfo`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => LnrpcGetRecoveryInfoResponseFromJSON(jsonValue));
    }

    /**
     * * lncli: `getrecoveryinfo` GetRecoveryInfo returns information concerning the recovery mode including whether it\'s in a recovery mode, whether the recovery is finished, and the progress made so far.
     */
    async getRecoveryInfo(initOverrides?: RequestInit): Promise<LnrpcGetRecoveryInfoResponse> {
        const response = await this.getRecoveryInfoRaw(initOverrides);
        return await response.value();
    }

    /**
     * lncli: `listchaintxns` GetTransactions returns a list describing all the known transactions relevant to the wallet.
     */
    async getTransactionsRaw(requestParameters: GetTransactionsRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<LnrpcTransactionDetails>> {
        const queryParameters: any = {};

        if (requestParameters.start_height !== undefined) {
            queryParameters['start_height'] = requestParameters.start_height;
        }

        if (requestParameters.end_height !== undefined) {
            queryParameters['end_height'] = requestParameters.end_height;
        }

        if (requestParameters.account !== undefined) {
            queryParameters['account'] = requestParameters.account;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/transactions`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => LnrpcTransactionDetailsFromJSON(jsonValue));
    }

    /**
     * lncli: `listchaintxns` GetTransactions returns a list describing all the known transactions relevant to the wallet.
     */
    async getTransactions(requestParameters: GetTransactionsRequest, initOverrides?: RequestInit): Promise<LnrpcTransactionDetails> {
        const response = await this.getTransactionsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * lncli: `listchannels` ListChannels returns a description of all the open channels that this node is a participant in.
     */
    async listChannelsRaw(requestParameters: ListChannelsRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<LnrpcListChannelsResponse>> {
        const queryParameters: any = {};

        if (requestParameters.active_only !== undefined) {
            queryParameters['active_only'] = requestParameters.active_only;
        }

        if (requestParameters.inactive_only !== undefined) {
            queryParameters['inactive_only'] = requestParameters.inactive_only;
        }

        if (requestParameters.public_only !== undefined) {
            queryParameters['public_only'] = requestParameters.public_only;
        }

        if (requestParameters.private_only !== undefined) {
            queryParameters['private_only'] = requestParameters.private_only;
        }

        if (requestParameters.peer !== undefined) {
            queryParameters['peer'] = requestParameters.peer;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/channels`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => LnrpcListChannelsResponseFromJSON(jsonValue));
    }

    /**
     * lncli: `listchannels` ListChannels returns a description of all the open channels that this node is a participant in.
     */
    async listChannels(requestParameters: ListChannelsRequest, initOverrides?: RequestInit): Promise<LnrpcListChannelsResponse> {
        const response = await this.listChannelsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * lncli: `listinvoices` ListInvoices returns a list of all the invoices currently stored within the database. Any active debug invoices are ignored. It has full support for paginated responses, allowing users to query for specific invoices through their add_index. This can be done by using either the first_index_offset or last_index_offset fields included in the response as the index_offset of the next request. By default, the first 100 invoices created will be returned. Backwards pagination is also supported through the Reversed flag.
     */
    async listInvoicesRaw(requestParameters: ListInvoicesRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<LnrpcListInvoiceResponse>> {
        const queryParameters: any = {};

        if (requestParameters.pending_only !== undefined) {
            queryParameters['pending_only'] = requestParameters.pending_only;
        }

        if (requestParameters.index_offset !== undefined) {
            queryParameters['index_offset'] = requestParameters.index_offset;
        }

        if (requestParameters.num_max_invoices !== undefined) {
            queryParameters['num_max_invoices'] = requestParameters.num_max_invoices;
        }

        if (requestParameters.reversed !== undefined) {
            queryParameters['reversed'] = requestParameters.reversed;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/invoices`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => LnrpcListInvoiceResponseFromJSON(jsonValue));
    }

    /**
     * lncli: `listinvoices` ListInvoices returns a list of all the invoices currently stored within the database. Any active debug invoices are ignored. It has full support for paginated responses, allowing users to query for specific invoices through their add_index. This can be done by using either the first_index_offset or last_index_offset fields included in the response as the index_offset of the next request. By default, the first 100 invoices created will be returned. Backwards pagination is also supported through the Reversed flag.
     */
    async listInvoices(requestParameters: ListInvoicesRequest, initOverrides?: RequestInit): Promise<LnrpcListInvoiceResponse> {
        const response = await this.listInvoicesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * lncli: `listmacaroonids` ListMacaroonIDs returns all root key IDs that are in use.
     */
    async listMacaroonIDsRaw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<LnrpcListMacaroonIDsResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/macaroon/ids`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => LnrpcListMacaroonIDsResponseFromJSON(jsonValue));
    }

    /**
     * lncli: `listmacaroonids` ListMacaroonIDs returns all root key IDs that are in use.
     */
    async listMacaroonIDs(initOverrides?: RequestInit): Promise<LnrpcListMacaroonIDsResponse> {
        const response = await this.listMacaroonIDsRaw(initOverrides);
        return await response.value();
    }

    /**
     * lncli: `listpayments` ListPayments returns a list of all outgoing payments.
     */
    async listPaymentsRaw(requestParameters: ListPaymentsRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<LnrpcListPaymentsResponse>> {
        const queryParameters: any = {};

        if (requestParameters.include_incomplete !== undefined) {
            queryParameters['include_incomplete'] = requestParameters.include_incomplete;
        }

        if (requestParameters.index_offset !== undefined) {
            queryParameters['index_offset'] = requestParameters.index_offset;
        }

        if (requestParameters.max_payments !== undefined) {
            queryParameters['max_payments'] = requestParameters.max_payments;
        }

        if (requestParameters.reversed !== undefined) {
            queryParameters['reversed'] = requestParameters.reversed;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/payments`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => LnrpcListPaymentsResponseFromJSON(jsonValue));
    }

    /**
     * lncli: `listpayments` ListPayments returns a list of all outgoing payments.
     */
    async listPayments(requestParameters: ListPaymentsRequest, initOverrides?: RequestInit): Promise<LnrpcListPaymentsResponse> {
        const response = await this.listPaymentsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * lncli: `listpeers` ListPeers returns a verbose listing of all currently active peers.
     */
    async listPeersRaw(requestParameters: ListPeersRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<LnrpcListPeersResponse>> {
        const queryParameters: any = {};

        if (requestParameters.latest_error !== undefined) {
            queryParameters['latest_error'] = requestParameters.latest_error;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/peers`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => LnrpcListPeersResponseFromJSON(jsonValue));
    }

    /**
     * lncli: `listpeers` ListPeers returns a verbose listing of all currently active peers.
     */
    async listPeers(requestParameters: ListPeersRequest, initOverrides?: RequestInit): Promise<LnrpcListPeersResponse> {
        const response = await this.listPeersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * lncli: `listpermissions` ListPermissions lists all RPC method URIs and their required macaroon permissions to access them.
     */
    async listPermissionsRaw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<LnrpcListPermissionsResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/macaroon/permissions`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => LnrpcListPermissionsResponseFromJSON(jsonValue));
    }

    /**
     * lncli: `listpermissions` ListPermissions lists all RPC method URIs and their required macaroon permissions to access them.
     */
    async listPermissions(initOverrides?: RequestInit): Promise<LnrpcListPermissionsResponse> {
        const response = await this.listPermissionsRaw(initOverrides);
        return await response.value();
    }

    /**
     * ListUnspent returns a list of all utxos spendable by the wallet with a number of confirmations between the specified minimum and maximum.
     * lncli: `listunspent` Deprecated, use walletrpc.ListUnspent instead.
     */
    async listUnspentRaw(requestParameters: ListUnspentRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<LnrpcListUnspentResponse>> {
        const queryParameters: any = {};

        if (requestParameters.min_confs !== undefined) {
            queryParameters['min_confs'] = requestParameters.min_confs;
        }

        if (requestParameters.max_confs !== undefined) {
            queryParameters['max_confs'] = requestParameters.max_confs;
        }

        if (requestParameters.account !== undefined) {
            queryParameters['account'] = requestParameters.account;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/utxos`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => LnrpcListUnspentResponseFromJSON(jsonValue));
    }

    /**
     * ListUnspent returns a list of all utxos spendable by the wallet with a number of confirmations between the specified minimum and maximum.
     * lncli: `listunspent` Deprecated, use walletrpc.ListUnspent instead.
     */
    async listUnspent(requestParameters: ListUnspentRequest, initOverrides?: RequestInit): Promise<LnrpcListUnspentResponse> {
        const response = await this.listUnspentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * lncli: `lookupinvoice` LookupInvoice attempts to look up an invoice according to its payment hash. The passed payment hash *must* be exactly 32 bytes, if not, an error is returned.
     */
    async lookupInvoiceRaw(requestParameters: LookupInvoiceRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<LnrpcInvoice>> {
        if (requestParameters.r_hash_str === null || requestParameters.r_hash_str === undefined) {
            throw new runtime.RequiredError('r_hash_str','Required parameter requestParameters.r_hash_str was null or undefined when calling lookupInvoice.');
        }

        const queryParameters: any = {};

        if (requestParameters.r_hash !== undefined) {
            queryParameters['r_hash'] = requestParameters.r_hash;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/invoice/{r_hash_str}`.replace(`{${"r_hash_str"}}`, encodeURIComponent(String(requestParameters.r_hash_str))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => LnrpcInvoiceFromJSON(jsonValue));
    }

    /**
     * lncli: `lookupinvoice` LookupInvoice attempts to look up an invoice according to its payment hash. The passed payment hash *must* be exactly 32 bytes, if not, an error is returned.
     */
    async lookupInvoice(requestParameters: LookupInvoiceRequest, initOverrides?: RequestInit): Promise<LnrpcInvoice> {
        const response = await this.lookupInvoiceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * lncli: `newaddress` NewAddress creates a new address under control of the local wallet.
     */
    async newAddressRaw(requestParameters: NewAddressRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<LnrpcNewAddressResponse>> {
        const queryParameters: any = {};

        if (requestParameters.type !== undefined) {
            queryParameters['type'] = requestParameters.type;
        }

        if (requestParameters.account !== undefined) {
            queryParameters['account'] = requestParameters.account;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/newaddress`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => LnrpcNewAddressResponseFromJSON(jsonValue));
    }

    /**
     * lncli: `newaddress` NewAddress creates a new address under control of the local wallet.
     */
    async newAddress(requestParameters: NewAddressRequest, initOverrides?: RequestInit): Promise<LnrpcNewAddressResponse> {
        const response = await this.newAddressRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * lncli: `openchannel` OpenChannel attempts to open a singly funded channel specified in the request to a remote peer. Users are able to specify a target number of blocks that the funding transaction should be confirmed in, or a manual fee rate to us for the funding transaction. If neither are specified, then a lax block confirmation target is used. Each OpenStatusUpdate will return the pending channel ID of the in-progress channel. Depending on the arguments specified in the OpenChannelRequest, this pending channel ID can then be used to manually progress the channel funding flow.
     */
    async openChannelRaw(requestParameters: OpenChannelRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<StreamResultOfLnrpcOpenStatusUpdate>> {
        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling openChannel.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/v1/channels/stream`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: LnrpcOpenChannelRequestToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StreamResultOfLnrpcOpenStatusUpdateFromJSON(jsonValue));
    }

    /**
     * lncli: `openchannel` OpenChannel attempts to open a singly funded channel specified in the request to a remote peer. Users are able to specify a target number of blocks that the funding transaction should be confirmed in, or a manual fee rate to us for the funding transaction. If neither are specified, then a lax block confirmation target is used. Each OpenStatusUpdate will return the pending channel ID of the in-progress channel. Depending on the arguments specified in the OpenChannelRequest, this pending channel ID can then be used to manually progress the channel funding flow.
     */
    async openChannel(requestParameters: OpenChannelRequest, initOverrides?: RequestInit): Promise<StreamResultOfLnrpcOpenStatusUpdate> {
        const response = await this.openChannelRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * OpenChannelSync is a synchronous version of the OpenChannel RPC call. This call is meant to be consumed by clients to the REST proxy. As with all other sync calls, all byte slices are intended to be populated as hex encoded strings.
     */
    async openChannelSyncRaw(requestParameters: OpenChannelSyncRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<LnrpcChannelPoint>> {
        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling openChannelSync.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/v1/channels`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: LnrpcOpenChannelRequestToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => LnrpcChannelPointFromJSON(jsonValue));
    }

    /**
     * OpenChannelSync is a synchronous version of the OpenChannel RPC call. This call is meant to be consumed by clients to the REST proxy. As with all other sync calls, all byte slices are intended to be populated as hex encoded strings.
     */
    async openChannelSync(requestParameters: OpenChannelSyncRequest, initOverrides?: RequestInit): Promise<LnrpcChannelPoint> {
        const response = await this.openChannelSyncRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * lncli: `pendingchannels` PendingChannels returns a list of all the channels that are currently considered \"pending\". A channel is pending if it has finished the funding workflow and is waiting for confirmations for the funding txn, or is in the process of closure, either initiated cooperatively or non-cooperatively.
     */
    async pendingChannelsRaw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<LnrpcPendingChannelsResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/channels/pending`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => LnrpcPendingChannelsResponseFromJSON(jsonValue));
    }

    /**
     * lncli: `pendingchannels` PendingChannels returns a list of all the channels that are currently considered \"pending\". A channel is pending if it has finished the funding workflow and is waiting for confirmations for the funding txn, or is in the process of closure, either initiated cooperatively or non-cooperatively.
     */
    async pendingChannels(initOverrides?: RequestInit): Promise<LnrpcPendingChannelsResponse> {
        const response = await this.pendingChannelsRaw(initOverrides);
        return await response.value();
    }

    /**
     * When using REST, the `dest_custom_records` map type can be set by appending `&dest_custom_records[<record_number>]=<record_data_base64_url_encoded>` to the URL. Unfortunately this map type doesn\'t appear in the REST API documentation because of a bug in the grpc-gateway library.
     * lncli: `queryroutes` QueryRoutes attempts to query the daemon\'s Channel Router for a possible route to a target destination capable of carrying a specific amount of satoshis. The returned route contains the full details required to craft and send an HTLC, also including the necessary information that should be present within the Sphinx packet encapsulated within the HTLC.
     */
    async queryRoutesRaw(requestParameters: QueryRoutesRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<LnrpcQueryRoutesResponse>> {
        if (requestParameters.pub_key === null || requestParameters.pub_key === undefined) {
            throw new runtime.RequiredError('pub_key','Required parameter requestParameters.pub_key was null or undefined when calling queryRoutes.');
        }

        if (requestParameters.amt === null || requestParameters.amt === undefined) {
            throw new runtime.RequiredError('amt','Required parameter requestParameters.amt was null or undefined when calling queryRoutes.');
        }

        const queryParameters: any = {};

        if (requestParameters.amt_msat !== undefined) {
            queryParameters['amt_msat'] = requestParameters.amt_msat;
        }

        if (requestParameters.final_cltv_delta !== undefined) {
            queryParameters['final_cltv_delta'] = requestParameters.final_cltv_delta;
        }

        if (requestParameters.fee_limit_fixed !== undefined) {
            queryParameters['fee_limit.fixed'] = requestParameters.fee_limit_fixed;
        }

        if (requestParameters.fee_limit_fixed_msat !== undefined) {
            queryParameters['fee_limit.fixed_msat'] = requestParameters.fee_limit_fixed_msat;
        }

        if (requestParameters.fee_limit_percent !== undefined) {
            queryParameters['fee_limit.percent'] = requestParameters.fee_limit_percent;
        }

        if (requestParameters.ignored_nodes) {
            queryParameters['ignored_nodes'] = requestParameters.ignored_nodes;
        }

        if (requestParameters.source_pub_key !== undefined) {
            queryParameters['source_pub_key'] = requestParameters.source_pub_key;
        }

        if (requestParameters.use_mission_control !== undefined) {
            queryParameters['use_mission_control'] = requestParameters.use_mission_control;
        }

        if (requestParameters.cltv_limit !== undefined) {
            queryParameters['cltv_limit'] = requestParameters.cltv_limit;
        }

        if (requestParameters.outgoing_chan_id !== undefined) {
            queryParameters['outgoing_chan_id'] = requestParameters.outgoing_chan_id;
        }

        if (requestParameters.last_hop_pubkey !== undefined) {
            queryParameters['last_hop_pubkey'] = requestParameters.last_hop_pubkey;
        }

        if (requestParameters.dest_features) {
            queryParameters['dest_features'] = requestParameters.dest_features;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/graph/routes/{pub_key}/{amt}`.replace(`{${"pub_key"}}`, encodeURIComponent(String(requestParameters.pub_key))).replace(`{${"amt"}}`, encodeURIComponent(String(requestParameters.amt))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => LnrpcQueryRoutesResponseFromJSON(jsonValue));
    }

    /**
     * When using REST, the `dest_custom_records` map type can be set by appending `&dest_custom_records[<record_number>]=<record_data_base64_url_encoded>` to the URL. Unfortunately this map type doesn\'t appear in the REST API documentation because of a bug in the grpc-gateway library.
     * lncli: `queryroutes` QueryRoutes attempts to query the daemon\'s Channel Router for a possible route to a target destination capable of carrying a specific amount of satoshis. The returned route contains the full details required to craft and send an HTLC, also including the necessary information that should be present within the Sphinx packet encapsulated within the HTLC.
     */
    async queryRoutes(requestParameters: QueryRoutesRequest, initOverrides?: RequestInit): Promise<LnrpcQueryRoutesResponse> {
        const response = await this.queryRoutesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * lncli: `restorechanbackup` RestoreChannelBackups accepts a set of singular channel backups, or a single encrypted multi-chan backup and attempts to recover any funds remaining within the channel. If we are able to unpack the backup, then the new channel will be shown under listchannels, as well as pending channels.
     */
    async restoreChannelBackupsRaw(requestParameters: RestoreChannelBackupsRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling restoreChannelBackups.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/v1/channels/backup/restore`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: LnrpcRestoreChanBackupRequestToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * lncli: `restorechanbackup` RestoreChannelBackups accepts a set of singular channel backups, or a single encrypted multi-chan backup and attempts to recover any funds remaining within the channel. If we are able to unpack the backup, then the new channel will be shown under listchannels, as well as pending channels.
     */
    async restoreChannelBackups(requestParameters: RestoreChannelBackupsRequest, initOverrides?: RequestInit): Promise<object> {
        const response = await this.restoreChannelBackupsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * lncli: `sendcoins` SendCoins executes a request to send coins to a particular address. Unlike SendMany, this RPC call only allows creating a single output at a time. If neither target_conf, or sat_per_vbyte are set, then the internal wallet will consult its fee model to determine a fee for the default confirmation target.
     */
    async sendCoinsRaw(requestParameters: SendCoinsRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<LnrpcSendCoinsResponse>> {
        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling sendCoins.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/v1/transactions`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: LnrpcSendCoinsRequestToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => LnrpcSendCoinsResponseFromJSON(jsonValue));
    }

    /**
     * lncli: `sendcoins` SendCoins executes a request to send coins to a particular address. Unlike SendMany, this RPC call only allows creating a single output at a time. If neither target_conf, or sat_per_vbyte are set, then the internal wallet will consult its fee model to determine a fee for the default confirmation target.
     */
    async sendCoins(requestParameters: SendCoinsRequest, initOverrides?: RequestInit): Promise<LnrpcSendCoinsResponse> {
        const response = await this.sendCoinsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * lncli: `sendmany` SendMany handles a request for a transaction that creates multiple specified outputs in parallel. If neither target_conf, or sat_per_vbyte are set, then the internal wallet will consult its fee model to determine a fee for the default confirmation target.
     */
    async sendManyRaw(requestParameters: SendManyRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<LnrpcSendManyResponse>> {
        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling sendMany.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/v1/transactions/many`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: LnrpcSendManyRequestToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => LnrpcSendManyResponseFromJSON(jsonValue));
    }

    /**
     * lncli: `sendmany` SendMany handles a request for a transaction that creates multiple specified outputs in parallel. If neither target_conf, or sat_per_vbyte are set, then the internal wallet will consult its fee model to determine a fee for the default confirmation target.
     */
    async sendMany(requestParameters: SendManyRequest, initOverrides?: RequestInit): Promise<LnrpcSendManyResponse> {
        const response = await this.sendManyRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * lncli: `sendpayment` Deprecated, use routerrpc.SendPaymentV2. SendPayment dispatches a bi-directional streaming RPC for sending payments through the Lightning Network. A single RPC invocation creates a persistent bi-directional stream allowing clients to rapidly send payments through the Lightning Network with a single persistent connection.
     */
    async sendPaymentRaw(requestParameters: SendPaymentRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<StreamResultOfLnrpcSendResponse>> {
        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling sendPayment.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/v1/channels/transaction-stream`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: LnrpcSendRequestToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StreamResultOfLnrpcSendResponseFromJSON(jsonValue));
    }

    /**
     * lncli: `sendpayment` Deprecated, use routerrpc.SendPaymentV2. SendPayment dispatches a bi-directional streaming RPC for sending payments through the Lightning Network. A single RPC invocation creates a persistent bi-directional stream allowing clients to rapidly send payments through the Lightning Network with a single persistent connection.
     */
    async sendPayment(requestParameters: SendPaymentRequest, initOverrides?: RequestInit): Promise<StreamResultOfLnrpcSendResponse> {
        const response = await this.sendPaymentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * SendPaymentSync is the synchronous non-streaming version of SendPayment. This RPC is intended to be consumed by clients of the REST proxy. Additionally, this RPC expects the destination\'s public key and the payment hash (if any) to be encoded as hex strings.
     */
    async sendPaymentSyncRaw(requestParameters: SendPaymentSyncRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<LnrpcSendResponse>> {
        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling sendPaymentSync.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/v1/channels/transactions`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: LnrpcSendRequestToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => LnrpcSendResponseFromJSON(jsonValue));
    }

    /**
     * SendPaymentSync is the synchronous non-streaming version of SendPayment. This RPC is intended to be consumed by clients of the REST proxy. Additionally, this RPC expects the destination\'s public key and the payment hash (if any) to be encoded as hex strings.
     */
    async sendPaymentSync(requestParameters: SendPaymentSyncRequest, initOverrides?: RequestInit): Promise<LnrpcSendResponse> {
        const response = await this.sendPaymentSyncRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * SendToRouteSync is a synchronous version of SendToRoute. It Will block until the payment either fails or succeeds.
     */
    async sendToRouteSyncRaw(requestParameters: SendToRouteSyncRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<LnrpcSendResponse>> {
        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling sendToRouteSync.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/v1/channels/transactions/route`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: LnrpcSendToRouteRequestToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => LnrpcSendResponseFromJSON(jsonValue));
    }

    /**
     * SendToRouteSync is a synchronous version of SendToRoute. It Will block until the payment either fails or succeeds.
     */
    async sendToRouteSync(requestParameters: SendToRouteSyncRequest, initOverrides?: RequestInit): Promise<LnrpcSendResponse> {
        const response = await this.sendToRouteSyncRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * lncli: `signmessage` SignMessage signs a message with this node\'s private key. The returned signature string is `zbase32` encoded and pubkey recoverable, meaning that only the message digest and signature are needed for verification.
     */
    async signMessageRaw(requestParameters: SignMessageRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<LnrpcSignMessageResponse>> {
        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling signMessage.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/v1/signmessage`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: LnrpcSignMessageRequestToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => LnrpcSignMessageResponseFromJSON(jsonValue));
    }

    /**
     * lncli: `signmessage` SignMessage signs a message with this node\'s private key. The returned signature string is `zbase32` encoded and pubkey recoverable, meaning that only the message digest and signature are needed for verification.
     */
    async signMessage(requestParameters: SignMessageRequest, initOverrides?: RequestInit): Promise<LnrpcSignMessageResponse> {
        const response = await this.signMessageRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * lncli: `stop` StopDaemon will send a shutdown request to the interrupt handler, triggering a graceful shutdown of the daemon.
     */
    async stopDaemonRaw(requestParameters: StopDaemonRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling stopDaemon.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/v1/stop`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * lncli: `stop` StopDaemon will send a shutdown request to the interrupt handler, triggering a graceful shutdown of the daemon.
     */
    async stopDaemon(requestParameters: StopDaemonRequest, initOverrides?: RequestInit): Promise<object> {
        const response = await this.stopDaemonRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * SubscribeChannelBackups allows a client to sub-subscribe to the most up to date information concerning the state of all channel backups. Each time a new channel is added, we return the new set of channels, along with a multi-chan backup containing the backup info for all channels. Each time a channel is closed, we send a new update, which contains new new chan back ups, but the updated set of encrypted multi-chan backups with the closed channel(s) removed.
     */
    async subscribeChannelBackupsRaw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<StreamResultOfLnrpcChanBackupSnapshot>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/channels/backup/subscribe`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StreamResultOfLnrpcChanBackupSnapshotFromJSON(jsonValue));
    }

    /**
     * SubscribeChannelBackups allows a client to sub-subscribe to the most up to date information concerning the state of all channel backups. Each time a new channel is added, we return the new set of channels, along with a multi-chan backup containing the backup info for all channels. Each time a channel is closed, we send a new update, which contains new new chan back ups, but the updated set of encrypted multi-chan backups with the closed channel(s) removed.
     */
    async subscribeChannelBackups(initOverrides?: RequestInit): Promise<StreamResultOfLnrpcChanBackupSnapshot> {
        const response = await this.subscribeChannelBackupsRaw(initOverrides);
        return await response.value();
    }

    /**
     * SubscribeChannelEvents creates a uni-directional stream from the server to the client in which any updates relevant to the state of the channels are sent over. Events include new active channels, inactive channels, and closed channels.
     */
    async subscribeChannelEventsRaw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<StreamResultOfLnrpcChannelEventUpdate>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/channels/subscribe`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StreamResultOfLnrpcChannelEventUpdateFromJSON(jsonValue));
    }

    /**
     * SubscribeChannelEvents creates a uni-directional stream from the server to the client in which any updates relevant to the state of the channels are sent over. Events include new active channels, inactive channels, and closed channels.
     */
    async subscribeChannelEvents(initOverrides?: RequestInit): Promise<StreamResultOfLnrpcChannelEventUpdate> {
        const response = await this.subscribeChannelEventsRaw(initOverrides);
        return await response.value();
    }

    /**
     * SubscribeChannelGraph launches a streaming RPC that allows the caller to receive notifications upon any changes to the channel graph topology from the point of view of the responding node. Events notified include: new nodes coming online, nodes updating their authenticated attributes, new channels being advertised, updates in the routing policy for a directional channel edge, and when channels are closed on-chain.
     */
    async subscribeChannelGraphRaw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<StreamResultOfLnrpcGraphTopologyUpdate>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/graph/subscribe`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StreamResultOfLnrpcGraphTopologyUpdateFromJSON(jsonValue));
    }

    /**
     * SubscribeChannelGraph launches a streaming RPC that allows the caller to receive notifications upon any changes to the channel graph topology from the point of view of the responding node. Events notified include: new nodes coming online, nodes updating their authenticated attributes, new channels being advertised, updates in the routing policy for a directional channel edge, and when channels are closed on-chain.
     */
    async subscribeChannelGraph(initOverrides?: RequestInit): Promise<StreamResultOfLnrpcGraphTopologyUpdate> {
        const response = await this.subscribeChannelGraphRaw(initOverrides);
        return await response.value();
    }

    /**
     * SubscribeInvoices returns a uni-directional stream (server -> client) for notifying the client of newly added/settled invoices. The caller can optionally specify the add_index and/or the settle_index. If the add_index is specified, then we\'ll first start by sending add invoice events for all invoices with an add_index greater than the specified value. If the settle_index is specified, the next, we\'ll send out all settle events for invoices with a settle_index greater than the specified value. One or both of these fields can be set. If no fields are set, then we\'ll only send out the latest add/settle events.
     */
    async subscribeInvoicesRaw(requestParameters: SubscribeInvoicesRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<StreamResultOfLnrpcInvoice>> {
        const queryParameters: any = {};

        if (requestParameters.add_index !== undefined) {
            queryParameters['add_index'] = requestParameters.add_index;
        }

        if (requestParameters.settle_index !== undefined) {
            queryParameters['settle_index'] = requestParameters.settle_index;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/invoices/subscribe`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StreamResultOfLnrpcInvoiceFromJSON(jsonValue));
    }

    /**
     * SubscribeInvoices returns a uni-directional stream (server -> client) for notifying the client of newly added/settled invoices. The caller can optionally specify the add_index and/or the settle_index. If the add_index is specified, then we\'ll first start by sending add invoice events for all invoices with an add_index greater than the specified value. If the settle_index is specified, the next, we\'ll send out all settle events for invoices with a settle_index greater than the specified value. One or both of these fields can be set. If no fields are set, then we\'ll only send out the latest add/settle events.
     */
    async subscribeInvoices(requestParameters: SubscribeInvoicesRequest, initOverrides?: RequestInit): Promise<StreamResultOfLnrpcInvoice> {
        const response = await this.subscribeInvoicesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * SubscribePeerEvents creates a uni-directional stream from the server to the client in which any events relevant to the state of peers are sent over. Events include peers going online and offline.
     */
    async subscribePeerEventsRaw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<StreamResultOfLnrpcPeerEvent>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/peers/subscribe`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StreamResultOfLnrpcPeerEventFromJSON(jsonValue));
    }

    /**
     * SubscribePeerEvents creates a uni-directional stream from the server to the client in which any events relevant to the state of peers are sent over. Events include peers going online and offline.
     */
    async subscribePeerEvents(initOverrides?: RequestInit): Promise<StreamResultOfLnrpcPeerEvent> {
        const response = await this.subscribePeerEventsRaw(initOverrides);
        return await response.value();
    }

    /**
     * SubscribeTransactions creates a uni-directional stream from the server to the client in which any newly discovered transactions relevant to the wallet are sent over.
     */
    async subscribeTransactionsRaw(requestParameters: SubscribeTransactionsRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<StreamResultOfLnrpcTransaction>> {
        const queryParameters: any = {};

        if (requestParameters.start_height !== undefined) {
            queryParameters['start_height'] = requestParameters.start_height;
        }

        if (requestParameters.end_height !== undefined) {
            queryParameters['end_height'] = requestParameters.end_height;
        }

        if (requestParameters.account !== undefined) {
            queryParameters['account'] = requestParameters.account;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/transactions/subscribe`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StreamResultOfLnrpcTransactionFromJSON(jsonValue));
    }

    /**
     * SubscribeTransactions creates a uni-directional stream from the server to the client in which any newly discovered transactions relevant to the wallet are sent over.
     */
    async subscribeTransactions(requestParameters: SubscribeTransactionsRequest, initOverrides?: RequestInit): Promise<StreamResultOfLnrpcTransaction> {
        const response = await this.subscribeTransactionsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * lncli: `updatechanpolicy` UpdateChannelPolicy allows the caller to update the fee schedule and channel policies for all channels globally, or a particular channel.
     */
    async updateChannelPolicyRaw(requestParameters: UpdateChannelPolicyRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling updateChannelPolicy.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/v1/chanpolicy`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: LnrpcPolicyUpdateRequestToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * lncli: `updatechanpolicy` UpdateChannelPolicy allows the caller to update the fee schedule and channel policies for all channels globally, or a particular channel.
     */
    async updateChannelPolicy(requestParameters: UpdateChannelPolicyRequest, initOverrides?: RequestInit): Promise<object> {
        const response = await this.updateChannelPolicyRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * VerifyChanBackup allows a caller to verify the integrity of a channel backup snapshot. This method will accept either a packed Single or a packed Multi. Specifying both will result in an error.
     */
    async verifyChanBackupRaw(requestParameters: VerifyChanBackupRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling verifyChanBackup.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/v1/channels/backup/verify`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: LnrpcChanBackupSnapshotToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * VerifyChanBackup allows a caller to verify the integrity of a channel backup snapshot. This method will accept either a packed Single or a packed Multi. Specifying both will result in an error.
     */
    async verifyChanBackup(requestParameters: VerifyChanBackupRequest, initOverrides?: RequestInit): Promise<object> {
        const response = await this.verifyChanBackupRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * lncli: `verifymessage` VerifyMessage verifies a signature over a msg. The signature must be zbase32 encoded and signed by an active node in the resident node\'s channel database. In addition to returning the validity of the signature, VerifyMessage also returns the recovered pubkey from the signature.
     */
    async verifyMessageRaw(requestParameters: VerifyMessageRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<LnrpcVerifyMessageResponse>> {
        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling verifyMessage.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/v1/verifymessage`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: LnrpcVerifyMessageRequestToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => LnrpcVerifyMessageResponseFromJSON(jsonValue));
    }

    /**
     * lncli: `verifymessage` VerifyMessage verifies a signature over a msg. The signature must be zbase32 encoded and signed by an active node in the resident node\'s channel database. In addition to returning the validity of the signature, VerifyMessage also returns the recovered pubkey from the signature.
     */
    async verifyMessage(requestParameters: VerifyMessageRequest, initOverrides?: RequestInit): Promise<LnrpcVerifyMessageResponse> {
        const response = await this.verifyMessageRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * lncli: `walletbalance` WalletBalance returns total unspent outputs(confirmed and unconfirmed), all confirmed unspent outputs and all unconfirmed unspent outputs under control of the wallet.
     */
    async walletBalanceRaw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<LnrpcWalletBalanceResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/balance/blockchain`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => LnrpcWalletBalanceResponseFromJSON(jsonValue));
    }

    /**
     * lncli: `walletbalance` WalletBalance returns total unspent outputs(confirmed and unconfirmed), all confirmed unspent outputs and all unconfirmed unspent outputs under control of the wallet.
     */
    async walletBalance(initOverrides?: RequestInit): Promise<LnrpcWalletBalanceResponse> {
        const response = await this.walletBalanceRaw(initOverrides);
        return await response.value();
    }

}

/**
    * @export
    * @enum {string}
    */
export enum GetNodeMetricsTypesEnum {
    Unknown = 'UNKNOWN',
    BetweennessCentrality = 'BETWEENNESS_CENTRALITY'
}
/**
    * @export
    * @enum {string}
    */
export enum NewAddressTypeEnum {
    WitnessPubkeyHash = 'WITNESS_PUBKEY_HASH',
    NestedPubkeyHash = 'NESTED_PUBKEY_HASH',
    UnusedWitnessPubkeyHash = 'UNUSED_WITNESS_PUBKEY_HASH',
    UnusedNestedPubkeyHash = 'UNUSED_NESTED_PUBKEY_HASH'
}
/**
    * @export
    * @enum {string}
    */
export enum QueryRoutesDestFeaturesEnum {
    DatalossProtectReq = 'DATALOSS_PROTECT_REQ',
    DatalossProtectOpt = 'DATALOSS_PROTECT_OPT',
    InitialRouingSync = 'INITIAL_ROUING_SYNC',
    UpfrontShutdownScriptReq = 'UPFRONT_SHUTDOWN_SCRIPT_REQ',
    UpfrontShutdownScriptOpt = 'UPFRONT_SHUTDOWN_SCRIPT_OPT',
    GossipQueriesReq = 'GOSSIP_QUERIES_REQ',
    GossipQueriesOpt = 'GOSSIP_QUERIES_OPT',
    TlvOnionReq = 'TLV_ONION_REQ',
    TlvOnionOpt = 'TLV_ONION_OPT',
    ExtGossipQueriesReq = 'EXT_GOSSIP_QUERIES_REQ',
    ExtGossipQueriesOpt = 'EXT_GOSSIP_QUERIES_OPT',
    StaticRemoteKeyReq = 'STATIC_REMOTE_KEY_REQ',
    StaticRemoteKeyOpt = 'STATIC_REMOTE_KEY_OPT',
    PaymentAddrReq = 'PAYMENT_ADDR_REQ',
    PaymentAddrOpt = 'PAYMENT_ADDR_OPT',
    MppReq = 'MPP_REQ',
    MppOpt = 'MPP_OPT',
    WumboChannelsReq = 'WUMBO_CHANNELS_REQ',
    WumboChannelsOpt = 'WUMBO_CHANNELS_OPT',
    AnchorsReq = 'ANCHORS_REQ',
    AnchorsOpt = 'ANCHORS_OPT',
    AnchorsZeroFeeHtlcReq = 'ANCHORS_ZERO_FEE_HTLC_REQ',
    AnchorsZeroFeeHtlcOpt = 'ANCHORS_ZERO_FEE_HTLC_OPT',
    AmpReq = 'AMP_REQ',
    AmpOpt = 'AMP_OPT'
}
