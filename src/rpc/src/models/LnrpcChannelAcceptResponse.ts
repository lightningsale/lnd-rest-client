/* tslint:disable */
/* eslint-disable */
/**
 * rpc.proto
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: version not set
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { exists, mapValues } from '../runtime';
/**
 * 
 * @export
 * @interface LnrpcChannelAcceptResponse
 */
export interface LnrpcChannelAcceptResponse {
    /**
     * Whether or not the client accepts the channel.
     * @type {boolean}
     * @memberof LnrpcChannelAcceptResponse
     */
    accept?: boolean;
    /**
     * The pending channel id to which this response applies.
     * @type {string}
     * @memberof LnrpcChannelAcceptResponse
     */
    pendingChanId?: string;
    /**
     * An optional error to send the initiating party to indicate why the channel
     * was rejected. This field *should not* contain sensitive information, it will
     * be sent to the initiating party. This field should only be set if accept is
     * false, the channel will be rejected if an error is set with accept=true
     * because the meaning of this response is ambiguous. Limited to 500
     * characters.
     * @type {string}
     * @memberof LnrpcChannelAcceptResponse
     */
    error?: string;
    /**
     * The upfront shutdown address to use if the initiating peer supports option
     * upfront shutdown script (see ListPeers for the features supported). Note
     * that the channel open will fail if this value is set for a peer that does
     * not support this feature bit.
     * @type {string}
     * @memberof LnrpcChannelAcceptResponse
     */
    upfrontShutdown?: string;
    /**
     * The csv delay (in blocks) that we require for the remote party.
     * @type {number}
     * @memberof LnrpcChannelAcceptResponse
     */
    csvDelay?: number;
    /**
     * The reserve amount in satoshis that we require the remote peer to adhere to.
     * We require that the remote peer always have some reserve amount allocated to
     * them so that there is always a disincentive to broadcast old state (if they
     * hold 0 sats on their side of the channel, there is nothing to lose).
     * @type {string}
     * @memberof LnrpcChannelAcceptResponse
     */
    reserveSat?: string;
    /**
     * The maximum amount of funds in millisatoshis that we allow the remote peer
     * to have in outstanding htlcs.
     * @type {string}
     * @memberof LnrpcChannelAcceptResponse
     */
    inFlightMaxMsat?: string;
    /**
     * The maximum number of htlcs that the remote peer can offer us.
     * @type {number}
     * @memberof LnrpcChannelAcceptResponse
     */
    maxHtlcCount?: number;
    /**
     * The minimum value in millisatoshis for incoming htlcs on the channel.
     * @type {string}
     * @memberof LnrpcChannelAcceptResponse
     */
    minHtlcIn?: string;
    /**
     * The number of confirmations we require before we consider the channel open.
     * @type {number}
     * @memberof LnrpcChannelAcceptResponse
     */
    minAcceptDepth?: number;
}

export function LnrpcChannelAcceptResponseFromJSON(json: any): LnrpcChannelAcceptResponse {
    return LnrpcChannelAcceptResponseFromJSONTyped(json, false);
}

export function LnrpcChannelAcceptResponseFromJSONTyped(json: any, ignoreDiscriminator: boolean): LnrpcChannelAcceptResponse {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        
        'accept': !exists(json, 'accept') ? undefined : json['accept'],
        'pendingChanId': !exists(json, 'pending_chan_id') ? undefined : json['pending_chan_id'],
        'error': !exists(json, 'error') ? undefined : json['error'],
        'upfrontShutdown': !exists(json, 'upfront_shutdown') ? undefined : json['upfront_shutdown'],
        'csvDelay': !exists(json, 'csv_delay') ? undefined : json['csv_delay'],
        'reserveSat': !exists(json, 'reserve_sat') ? undefined : json['reserve_sat'],
        'inFlightMaxMsat': !exists(json, 'in_flight_max_msat') ? undefined : json['in_flight_max_msat'],
        'maxHtlcCount': !exists(json, 'max_htlc_count') ? undefined : json['max_htlc_count'],
        'minHtlcIn': !exists(json, 'min_htlc_in') ? undefined : json['min_htlc_in'],
        'minAcceptDepth': !exists(json, 'min_accept_depth') ? undefined : json['min_accept_depth'],
    };
}

export function LnrpcChannelAcceptResponseToJSON(value?: LnrpcChannelAcceptResponse | null): any {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        
        'accept': value.accept,
        'pending_chan_id': value.pendingChanId,
        'error': value.error,
        'upfront_shutdown': value.upfrontShutdown,
        'csv_delay': value.csvDelay,
        'reserve_sat': value.reserveSat,
        'in_flight_max_msat': value.inFlightMaxMsat,
        'max_htlc_count': value.maxHtlcCount,
        'min_htlc_in': value.minHtlcIn,
        'min_accept_depth': value.minAcceptDepth,
    };
}

