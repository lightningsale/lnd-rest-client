"use strict";
/* tslint:disable */
/* eslint-disable */
/**
 * rpc.proto
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: version not set
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 *  - RESERVED: The numbers assigned in this enumeration match the failure codes as
 * defined in BOLT #4. Because protobuf 3 requires enums to start with 0,
 * a RESERVED value is added.
 *  - INTERNAL_FAILURE: An internal error occurred.
 *  - UNKNOWN_FAILURE: The error source is known, but the failure itself couldn't be decoded.
 *  - UNREADABLE_FAILURE: An unreadable failure result is returned if the received failure message
 * cannot be decrypted. In that case the error source is unknown.
 * @export
 * @enum {string}
 */
var FailureFailureCode;
(function (FailureFailureCode) {
    FailureFailureCode["Reserved"] = "RESERVED";
    FailureFailureCode["IncorrectOrUnknownPaymentDetails"] = "INCORRECT_OR_UNKNOWN_PAYMENT_DETAILS";
    FailureFailureCode["IncorrectPaymentAmount"] = "INCORRECT_PAYMENT_AMOUNT";
    FailureFailureCode["FinalIncorrectCltvExpiry"] = "FINAL_INCORRECT_CLTV_EXPIRY";
    FailureFailureCode["FinalIncorrectHtlcAmount"] = "FINAL_INCORRECT_HTLC_AMOUNT";
    FailureFailureCode["FinalExpiryTooSoon"] = "FINAL_EXPIRY_TOO_SOON";
    FailureFailureCode["InvalidRealm"] = "INVALID_REALM";
    FailureFailureCode["ExpiryTooSoon"] = "EXPIRY_TOO_SOON";
    FailureFailureCode["InvalidOnionVersion"] = "INVALID_ONION_VERSION";
    FailureFailureCode["InvalidOnionHmac"] = "INVALID_ONION_HMAC";
    FailureFailureCode["InvalidOnionKey"] = "INVALID_ONION_KEY";
    FailureFailureCode["AmountBelowMinimum"] = "AMOUNT_BELOW_MINIMUM";
    FailureFailureCode["FeeInsufficient"] = "FEE_INSUFFICIENT";
    FailureFailureCode["IncorrectCltvExpiry"] = "INCORRECT_CLTV_EXPIRY";
    FailureFailureCode["ChannelDisabled"] = "CHANNEL_DISABLED";
    FailureFailureCode["TemporaryChannelFailure"] = "TEMPORARY_CHANNEL_FAILURE";
    FailureFailureCode["RequiredNodeFeatureMissing"] = "REQUIRED_NODE_FEATURE_MISSING";
    FailureFailureCode["RequiredChannelFeatureMissing"] = "REQUIRED_CHANNEL_FEATURE_MISSING";
    FailureFailureCode["UnknownNextPeer"] = "UNKNOWN_NEXT_PEER";
    FailureFailureCode["TemporaryNodeFailure"] = "TEMPORARY_NODE_FAILURE";
    FailureFailureCode["PermanentNodeFailure"] = "PERMANENT_NODE_FAILURE";
    FailureFailureCode["PermanentChannelFailure"] = "PERMANENT_CHANNEL_FAILURE";
    FailureFailureCode["ExpiryTooFar"] = "EXPIRY_TOO_FAR";
    FailureFailureCode["MppTimeout"] = "MPP_TIMEOUT";
    FailureFailureCode["InvalidOnionPayload"] = "INVALID_ONION_PAYLOAD";
    FailureFailureCode["InternalFailure"] = "INTERNAL_FAILURE";
    FailureFailureCode["UnknownFailure"] = "UNKNOWN_FAILURE";
    FailureFailureCode["UnreadableFailure"] = "UNREADABLE_FAILURE";
})(FailureFailureCode = exports.FailureFailureCode || (exports.FailureFailureCode = {}));
function FailureFailureCodeFromJSON(json) {
    return FailureFailureCodeFromJSONTyped(json, false);
}
exports.FailureFailureCodeFromJSON = FailureFailureCodeFromJSON;
function FailureFailureCodeFromJSONTyped(json, ignoreDiscriminator) {
    return json;
}
exports.FailureFailureCodeFromJSONTyped = FailureFailureCodeFromJSONTyped;
function FailureFailureCodeToJSON(value) {
    return value;
}
exports.FailureFailureCodeToJSON = FailureFailureCodeToJSON;
